# Krutaka v0.3.0 ‚Äî Graduated Command Execution

> **Version:** v0.3.0  
> **Status:** üü° Planning  
> **Planned Start:** 2026-02-14  
> **Predecessor:** v0.2.0 (‚úÖ Complete ‚Äî 903 tests, dynamic directory scoping)  
> **Milestone:** [v0.3.0](https://github.com/chethandvg/krutaka/milestone/3)

---

## Table of Contents

- [Executive Summary](#executive-summary)
- [Problem Statement](#problem-statement)
- [Goals and Non-Goals](#goals-and-non-goals)
- [Architecture Design](#architecture-design)
  - [Current State (v0.2.0)](#current-state-v020)
  - [Target State (v0.3.0)](#target-state-v030)
  - [Command Risk Tier Model](#command-risk-tier-model)
  - [Classification Algorithm](#classification-algorithm)
  - [Default Tier Assignments](#default-tier-assignments)
  - [Tiered Evaluation Logic](#tiered-evaluation-logic)
  - [Configurable Tier Overrides](#configurable-tier-overrides)
  - [Component Diagram](#component-diagram)
  - [Data Flow: Command Execution Request](#data-flow-command-execution-request)
- [Security Analysis](#security-analysis)
  - [Threat Model](#threat-model)
  - [Attack Surface Changes](#attack-surface-changes)
  - [Immutable Security Boundaries](#immutable-security-boundaries)
  - [New Attack Vectors and Mitigations](#new-attack-vectors-and-mitigations)
  - [Design Decision: Reject Dynamic Trust Progression](#design-decision-reject-dynamic-trust-progression)
  - [Configuration Tampering Prevention](#configuration-tampering-prevention)
  - [Argument Classification Edge Cases](#argument-classification-edge-cases)
- [Approval UI Changes](#approval-ui-changes)
- [System Prompt Changes](#system-prompt-changes)
- [Audit Logging Changes](#audit-logging-changes)
- [Implementation Roadmap](#implementation-roadmap)
  - [Issue Dependency Graph](#issue-dependency-graph)
  - [Issue Summary Table](#issue-summary-table)
- [Testing Strategy](#testing-strategy)
- [Rollback Plan](#rollback-plan)
- [Risks and Mitigations](#risks-and-mitigations)
- [Success Criteria](#success-criteria)
- [Related Documents](#related-documents)

---

## Executive Summary

v0.3.0 evolves command execution from a **static binary allowlist/blocklist** into a **tiered risk classification model**. Commands are classified as Safe (auto-approved), Moderate (context-dependent), Elevated (always prompted), or Dangerous (always blocked). This dramatically reduces approval fatigue for safe commands like `git status` while maintaining strict controls for operations like `git push` or `npm install`.

The classification is **static and predictable** ‚Äî it does NOT change during a session. The agent does NOT "earn" trust. Every command's tier is determined by its executable name and arguments at classification time.

---

## Problem Statement

### Current Limitation (v0.2.0)

In v0.2.0, every `run_command` invocation requires human approval, regardless of risk level:

```text
User: "Check the git status"
Claude: calls run_command(executable: "git", arguments: ["status"])
System: ‚öô Claude wants to run: git status
        Allow? [Y]es / [N]o
User: *presses Y for the 50th time*
```

This creates serious friction:

1. **Approval fatigue** ‚Äî Users rubber-stamp every command because most are harmless
2. **Workflow interruption** ‚Äî Claude chains like `git status` ‚Üí `dotnet build` ‚Üí `dotnet test` require 3 manual approvals
3. **Read-only commands have same friction as destructive ones** ‚Äî `git status` requires the same ceremony as `git push --force`
4. **Diminished security** ‚Äî When users approve everything habitually, they stop reading prompts ‚Äî defeating the purpose of human-in-the-loop

### Root Cause

`CommandPolicy.IsApprovalRequired()` returns `true` for ALL `run_command` invocations. There is no mechanism to distinguish safe reads from dangerous writes.

```csharp
// Current v0.2.0 ‚Äî binary, no nuance
private static readonly HashSet<string> ToolsRequiringApproval = new(StringComparer.OrdinalIgnoreCase)
{
    "write_file", "edit_file", "run_command"  // ‚Üê run_command is always here
};
```

---

## Goals and Non-Goals

### Goals

- ‚úÖ Classify commands into 4 risk tiers based on executable + arguments
- ‚úÖ Auto-approve Safe commands (zero user friction)
- ‚úÖ Auto-approve Moderate commands in trusted directories (synergy with v0.2.0)
- ‚úÖ Always prompt for Elevated commands
- ‚úÖ Always block Dangerous commands (existing behavior, unchanged)
- ‚úÖ Allow users to configure tier overrides for custom toolchains via `appsettings.json`
- ‚úÖ Prevent configuration from promoting Dangerous commands (safety invariant)
- ‚úÖ Show tier information in approval prompts
- ‚úÖ Tell Claude about tiers via system prompt (reduce denied command attempts)
- ‚úÖ Log every command with its tier and approval status

### Non-Goals

- ‚ùå Dynamic trust progression (agent "earns" trust during a session)
- ‚ùå Changes to `write_file`/`edit_file` approval logic
- ‚ùå Changes to directory access policy engine (consumed as-is from v0.2.0)
- ‚ùå New tool types or tool additions
- ‚ùå Remote execution (Telegram ‚Äî that's v0.4.0)

---

## Architecture Design

### Current State (v0.2.0)

```text
RunCommandTool.ExecuteAsync()
  ‚Üí ISecurityPolicy.ValidateCommand()    [blocklist + metacharacter check]
  ‚Üí Always requires approval              [IsApprovalRequired("run_command") == true]
  ‚Üí Execute via CliWrap                   [if approved]
```

### Target State (v0.3.0)

```text
RunCommandTool.ExecuteAsync()
  ‚Üí ICommandPolicy.EvaluateAsync()
      ‚Üí ISecurityPolicy.ValidateCommand()    [blocklist + metacharacter check ‚Äî ALWAYS FIRST]
      ‚Üí ICommandRiskClassifier.Classify()     [determine tier]
      ‚Üí Tier evaluation:
          Safe     ‚Üí CommandDecision.Approve()             [auto-approved]
          Moderate ‚Üí Check IAccessPolicyEngine for dir trust
                     ‚Üí Trusted dir ‚Üí CommandDecision.Approve()
                     ‚Üí Untrusted  ‚Üí CommandDecision.RequireApproval()
          Elevated ‚Üí CommandDecision.RequireApproval()     [always prompted]
          Dangerous ‚Üí throw SecurityException              [defense-in-depth]
  ‚Üí If RequiresApproval ‚Üí throw CommandApprovalRequiredException ‚Üí approval flow
  ‚Üí If Approved ‚Üí Execute via CliWrap
```

### Command Risk Tier Model

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  DANGEROUS (Always Blocked)               ‚îÇ
‚îÇ  format, diskpart, powershell, cmd, curl, wget, etc.     ‚îÇ
‚îÇ  ‚Üí SecurityException ‚Äî NEVER executes                     ‚îÇ
‚îÇ  ‚Üí Immutable: cannot be changed via config                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                  ELEVATED (Approval Required)              ‚îÇ
‚îÇ  git push/pull/fetch/clone/rebase/reset/cherry-pick       ‚îÇ
‚îÇ  dotnet publish/pack/nuget/new/tool                       ‚îÇ
‚îÇ  npm install/uninstall/update/publish/link                ‚îÇ
‚îÇ  pip install/uninstall/download                           ‚îÇ
‚îÇ  ‚Üí Requires explicit per-invocation approval              ‚îÇ
‚îÇ  ‚Üí No "Always" option (same as current run_command)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                  MODERATE (Context-Dependent)              ‚îÇ
‚îÇ  git add/commit/stash/checkout/switch/merge               ‚îÇ
‚îÇ  dotnet build/test/run/restore/clean/format               ‚îÇ
‚îÇ  npm/npx run/test/start/lint/build                        ‚îÇ
‚îÇ  python/python3 (script execution)                        ‚îÇ
‚îÇ  mkdir                                                    ‚îÇ
‚îÇ  ‚Üí Auto-approved in trusted directories (v0.2.0 synergy)  ‚îÇ
‚îÇ  ‚Üí Prompted elsewhere with "Always" option                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄÔøΩÔøΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                  SAFE (Auto-Approved)                      ‚îÇ
‚îÇ  git status/log/diff/show/branch/tag/remote/rev-parse     ‚îÇ
‚îÇ  dotnet --version/--info/--list-sdks/--list-runtimes       ‚îÇ
‚îÇ  node/npm/python/pip --version                            ‚îÇ
‚îÇ  pip list/show/freeze                                     ‚îÇ
‚îÇ  cat, type, find, dir, where, grep, findstr, tree         ‚îÇ
‚îÇ  echo, sort, head, tail, wc, diff                         ‚îÇ
‚îÇ  ‚Üí Always auto-approved, logged at Debug level             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Classification Algorithm

```text
Input: CommandExecutionRequest(executable, arguments, workingDir, justification)
Output: CommandRiskTier

1. Strip .exe suffix (case-insensitive)
2. Check BlockedExecutables set ‚Üí return Dangerous
3. Look up executable in default rules:
   a. If no rules exist for this executable ‚Üí return Dangerous (fail-closed)
   b. If rules exist:
      i.   Match first argument against argument patterns (case-insensitive)
      ii.  For dotnet: match first TWO arguments (e.g., "nuget push")
      iii. If argument pattern matches ‚Üí return that rule's tier
      iv.  If no argument pattern matches ‚Üí return executable's default tier
           (highest non-Safe tier for that executable)
4. Check user-configured TierOverrides (same matching logic)
   - User rules are checked AFTER default rules
   - User rules can override default tier for an executable+args combo
   - User rules CANNOT override Dangerous (blocklisted) executables
```

### Default Tier Assignments

#### Safe Tier (auto-approved)

| Executable | Argument Patterns | Notes |
|---|---|---|
| `git` | `status`, `log`, `diff`, `show`, `branch`, `tag`, `remote`, `rev-parse` | Read-only git operations |
| `dotnet` | `--version`, `--info`, `--list-sdks`, `--list-runtimes` | Information queries |
| `node` | `--version` | Version check |
| `npm` | `--version` | Version check |
| `python` / `python3` | `--version` | Version check |
| `pip` | `--version`, `list`, `show`, `freeze` | Read-only pip operations |
| `cat` | *(any args)* | Read-only by nature |
| `type` | *(any args)* | Read-only by nature |
| `find` | *(any args)* | Read-only by nature |
| `dir` | *(any args)* | Read-only by nature |
| `where` | *(any args)* | Read-only by nature |
| `grep` | *(any args)* | Read-only by nature |
| `findstr` | *(any args)* | Read-only by nature |
| `tree` | *(any args)* | Read-only by nature |
| `echo` | *(any args)* | Output-only by nature |
| `sort` | *(any args)* | Read-only by nature |
| `head` | *(any args)* | Read-only by nature |
| `tail` | *(any args)* | Read-only by nature |
| `wc` | *(any args)* | Read-only by nature |
| `diff` | *(any args)* | Read-only by nature |

#### Moderate Tier (context-dependent)

| Executable | Argument Patterns | Notes |
|---|---|---|
| `git` | `add`, `commit`, `stash`, `checkout`, `switch`, `merge` | Local-only operations |
| `dotnet` | `build`, `test`, `run`, `restore`, `clean`, `format` | Build/test operations |
| `npm` / `npx` | `run`, `test`, `start`, `lint`, `build` | Project script execution |
| `python` / `python3` | *(default for unmatched args)* | Script execution |
| `mkdir` | *(any args)* | Directory creation |

#### Elevated Tier (always prompted)

| Executable | Argument Patterns | Notes |
|---|---|---|
| `git` | `push`, `pull`, `fetch`, `clone`, `rebase`, `reset`, `cherry-pick` | Remote or history-altering operations |
| `dotnet` | `publish`, `pack`, `nuget`, `new`, `tool` | Package/project management |
| `npm` | `install`, `uninstall`, `update`, `publish`, `link` | Dependency management |
| `pip` | `install`, `uninstall`, `download` | Dependency management |

#### Dangerous Tier (always blocked)

All executables in the existing `BlockedExecutables` set:
`powershell`, `pwsh`, `cmd`, `reg`, `regedit`, `netsh`, `netstat`, `certutil`, `bitsadmin`, `format`, `diskpart`, `chkdsk`, `rundll32`, `regsvr32`, `mshta`, `wscript`, `cscript`, `msiexec`, `sc`, `schtasks`, `taskkill`, `net`, `net1`, `runas`, `icacls`, `takeown`, `curl`, `wget`, `invoke-webrequest`

Plus: any executable not found in any tier ‚Üí Dangerous (fail-closed).

### Tiered Evaluation Logic

```text
GraduatedCommandPolicy.EvaluateAsync(request):

  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Step 1: Pre-check (SECURITY BOUNDARY) ‚îÇ
  ‚îÇ ISecurityPolicy.ValidateCommand()     ‚îÇ
  ‚îÇ - Shell metacharacter check            ‚îÇ
  ‚îÇ - Blocklist check                      ‚îÇ
  ‚îÇ - Path separator check                 ‚îÇ
  ‚îÇ Throws SecurityException on failure    ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ passes
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Step 2: Classify                      ‚îÇ
  ‚îÇ ICommandRiskClassifier.Classify()     ‚îÇ
  ‚îÇ Returns CommandRiskTier               ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄÔøΩÔøΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚ñº          ‚ñº          ‚ñº              ‚ñº
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ Safe ‚îÇ ‚îÇModerate‚îÇ ‚îÇElevated‚îÇ ‚îÇDangerous ‚îÇ
   ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ         ‚îÇ          ‚îÇ            ‚îÇ
      ‚ñº         ‚ñº          ‚ñº            ‚ñº
   Approve   Check dir   Require     Throw
   (auto)    trust       Approval    SecurityException
             ‚îÇ                       (defense-in-depth)
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚ñº         ‚ñº
     Trusted?  Untrusted?
        ‚îÇ         ‚îÇ
        ‚ñº         ‚ñº
     Approve   Require
     (auto)    Approval
```

### Configurable Tier Overrides

Users can add custom commands or adjust existing tier assignments via `appsettings.json`:

```json
{
  "CommandPolicy": {
    "TierOverrides": [
      {
        "Executable": "cargo",
        "ArgumentPatterns": ["build", "test", "check"],
        "Tier": "Moderate",
        "Description": "Cargo build commands"
      },
      {
        "Executable": "cargo",
        "ArgumentPatterns": ["publish"],
        "Tier": "Elevated",
        "Description": "Cargo publish to registry"
      },
      {
        "Executable": "make",
        "ArgumentPatterns": null,
        "Tier": "Moderate",
        "Description": "GNU Make"
      }
    ],
    "ModerateAutoApproveInTrustedDirs": true
  }
}
```

#### Configuration Safety Invariants

These are enforced at startup by `CommandTierConfigValidator` (fail-fast):

1. **Cannot promote Dangerous commands** ‚Äî Any executable in `BlockedExecutables` CANNOT be assigned any other tier via config
2. **Cannot assign Dangerous tier** ‚Äî Users cannot add to the blocklist via config (code-only change)
3. **No path separators** ‚Äî Executable must be a simple name
4. **No shell metacharacters** ‚Äî Neither in executable nor in argument patterns
5. **Validation errors block startup** ‚Äî Invalid configs throw `InvalidOperationException`
6. **Warnings logged but don't block** ‚Äî Overly broad rules (null argument patterns) are warned

### Component Diagram

```text
Krutaka.Core (new types):
‚îú‚îÄ‚îÄ CommandRiskTier              [enum: Safe, Moderate, Elevated, Dangerous]
‚îú‚îÄ‚îÄ CommandRiskRule               [record: executable + args ‚Üí tier]
‚îú‚îÄ‚îÄ CommandExecutionRequest       [record: input to policy]
‚îú‚îÄ‚îÄ CommandDecision               [record: output from policy]
‚îú‚îÄ‚îÄ ICommandRiskClassifier        [interface: classify commands]
‚îú‚îÄ‚îÄ ICommandPolicy                [interface: evaluate command requests]
‚îî‚îÄ‚îÄ CommandApprovalRequiredException [exception: tier-based approval signal]

Krutaka.Tools (new implementations):
‚îú‚îÄ‚îÄ CommandRiskClassifier         [implements ICommandRiskClassifier]
‚îú‚îÄ‚îÄ GraduatedCommandPolicy        [implements ICommandPolicy]
‚îú‚îÄ‚îÄ CommandPolicyOptions          [options class for config]
‚îî‚îÄ‚îÄ CommandTierConfigValidator    [startup validation]

Krutaka.Console (modified):
‚îú‚îÄ‚îÄ ApprovalHandler               [tier-aware display]
‚îî‚îÄ‚îÄ ServiceExtensions             [register new services]
```

### Data Flow: Command Execution Request

```text
1. Claude calls run_command(executable: "git", arguments: ["status"])
2. AgentOrchestrator dispatches to RunCommandTool
3. RunCommandTool builds CommandExecutionRequest
4. RunCommandTool calls ICommandPolicy.EvaluateAsync()
   a. GraduatedCommandPolicy calls ISecurityPolicy.ValidateCommand() ‚Äî pre-check
   b. GraduatedCommandPolicy calls ICommandRiskClassifier.Classify() ‚Üí Safe
   c. GraduatedCommandPolicy returns CommandDecision(Approved: true, RequiresApproval: false)
5. RunCommandTool sees RequiresApproval == false ‚Üí executes directly
6. Output returned to Claude via tool result

Alternate flow (Elevated):
1. Claude calls run_command(executable: "git", arguments: ["push", "origin", "main"])
4c. Classifier returns Elevated
4d. GraduatedCommandPolicy returns CommandDecision(RequiresApproval: true)
5. RunCommandTool throws CommandApprovalRequiredException
6. AgentOrchestrator catches exception, triggers ApprovalHandler
7. User sees: "‚öô Claude wants to run: git push origin main ‚Äî Risk: üü° ELEVATED"
8. User approves ‚Üí RunCommandTool re-executes ‚Üí output returned
```

---

## Security Analysis

### Threat Model

| # | Threat | Severity | Attack Vector | Mitigation | Status |
|---|---|---|---|---|---|
| T1 | Safe tier bypass | High | Craft arguments so destructive command classifies as Safe | Classification is code-side, not AI-determined. Arguments are pattern-matched against hardcoded rules. Unknown args ‚Üí higher default tier. | Mitigated |
| T2 | Argument pattern evasion | Critical | Use alias (`-f` for `--force`) to evade classification | Known aliases handled. Unknown aliases ‚Üí executable's default tier (not Safe). Shell metacharacter check runs FIRST. | Mitigated |
| T3 | Moderate auto-approve abuse | Medium | Chain many Moderate commands to achieve Elevated-equivalent effect | Each command classified independently. Audit log captures all auto-approvals. Per-session review possible. | Accepted (low residual risk) |
| T4 | Configuration tampering | High | Modify `appsettings.json` to promote Dangerous commands to Safe | Hardcoded floor: `BlockedExecutables` can NEVER be promoted via config. Startup validation rejects invalid configs. | Mitigated |
| T5 | New command addition without review | Medium | User adds unvetted command to Safe tier via config | Config can only set Safe/Moderate/Elevated (not Dangerous). Unknown executables start as Dangerous in default rules. Config override allows explicit promotion. | Accepted (user responsibility) |
| T6 | Argument injection via safe commands | High | `echo something > file.txt` via redirect metacharacter | Shell metacharacter check runs BEFORE tier classification. The `>` would be blocked by existing `ShellMetacharacters` check. | Mitigated (existing control) |
| T7 | Classification complexity bugs | Medium | Edge case in classifier logic misclassifies a command | Exhaustive test coverage (~60 adversarial tests). Fail-closed for unknown commands. | Mitigated |

### Attack Surface Changes

| Component | v0.2.0 Surface | v0.3.0 Surface | Change |
|---|---|---|---|
| Command execution | Binary allow/block | Tiered allow/block | Increased complexity, but strictness preserved |
| Approval flow | Always prompted for run_command | Conditional based on tier | Reduced prompts, but Safe/Moderate auto-approve |
| Configuration | No command config | Tier overrides in appsettings | New config surface, validated at startup |
| System prompt | Static command info | Dynamic tier listing | Informational only, no security impact |

### Immutable Security Boundaries

These controls NEVER change across any version:

1. ‚úÖ **Shell metacharacter check runs FIRST** ‚Äî Before classification, before everything
2. ‚úÖ **Dangerous commands are ALWAYS blocked** ‚Äî `powershell`, `cmd`, `format`, etc.
3. ‚úÖ **CliWrap argument arrays** ‚Äî Never string interpolation for commands
4. ‚úÖ **Environment scrubbing** ‚Äî Always before child process spawn
5. ‚úÖ **Job Object sandboxing** ‚Äî Memory/CPU limits on all spawned processes
6. ‚úÖ **CancellationToken on everything** ‚Äî Timeout enforcement preserved
7. ‚úÖ **Path validation** ‚Äî Dynamic directory scoping from v0.2.0 preserved
8. ‚úÖ **Audit logging** ‚Äî Every command logged with correlation IDs
9. ‚úÖ **Untrusted content tagging** ‚Äî Command output wrapped in XML tags

### New Attack Vectors and Mitigations

#### Vector 1: Argument Aliasing

**Attack:** `git push -f` classified differently than `git push --force`

**Mitigation:** Classification matches on first argument only (`push`), not on flags. Both `git push -f` and `git push --force` match the `push` pattern ‚Üí Elevated. Flags don't change the tier.

#### Vector 2: Compound Command Evasion

**Attack:** `dotnet nuget push` ‚Äî is this `dotnet` + `nuget` (Elevated) or `dotnet` + unknown?

**Mitigation:** For `dotnet`, classifier checks first TWO arguments. `dotnet nuget` matches the Elevated tier rule for `["nuget"]` first argument. If `dotnet nuget push` ‚Äî `nuget` matches Elevated, done.

#### Vector 3: Configuration File Tampering

**Attack:** Attacker modifies `appsettings.json` to set `powershell` to `Safe`.

**Mitigation:** `CommandTierConfigValidator` checks every override against the hardcoded `BlockedExecutables` set. Any attempt to override a blocked executable throws `InvalidOperationException` at startup, preventing the application from running with an unsafe configuration.

#### Vector 4: Unknown Executable Promotion

**Attack:** User adds `evil-tool` to config as `Safe`, then agent runs it.

**Mitigation:** This is user responsibility (they control their own config). The executable must still be in the allowlist to pass `ISecurityPolicy.ValidateCommand()`. If `evil-tool` is not in `AllowedExecutables`, it will be blocked by the pre-check regardless of tier config.

**Important:** Tier overrides only affect the TIER (approval behavior). The allowlist check in `ISecurityPolicy.ValidateCommand()` is independent. A command must be BOTH allowed (by allowlist) AND classified (by tier) to execute. Adding a tier override for an unlisted executable will cause it to be classified as the configured tier, but it will still fail the allowlist check unless the executable is also in `AllowedExecutables`. A future improvement could auto-add tier-overridden executables to the allowlist, but v0.3.0 keeps them separate for defense-in-depth.

#### Vector 5: Argument Pattern Exhaustion

**Attack:** Provide hundreds of arguments to overwhelm the classifier.

**Mitigation:** The classifier only checks the FIRST argument (or first two for `dotnet`). Additional arguments are irrelevant to tier classification. Shell metacharacter validation still runs on ALL arguments. No performance concern.

### Design Decision: Reject Dynamic Trust Progression

The original roadmap proposed that the agent "earns trust" during a session:

> "Session starts ‚Üí Safe commands only ‚Üí Agent completes safe tasks ‚Üí Moderate unlocks"

**Decision: REJECTED.** This was rejected for the following reasons:

| Concern | Explanation |
|---|---|
| Unpredictable state | Security boundary changes during a session ‚Äî hard to reason about, hard to audit |
| Gaming risk | Agent could deliberately run `git status` 10 times to unlock `dotnet build` |
| User confusion | "Why did the agent stop asking for approval?" if trust silently escalates |
| Audit complexity | Can't determine if a command was auto-approved due to static config or dynamic trust |
| Simplicity | Static tiers are predictable, auditable, and don't surprise users |

**Instead:** Tier assignment is static and determined at classification time. The only context-dependent behavior is Moderate tier commands in trusted directories (which leverages the already-approved v0.2.0 directory scoping, not session-accumulated trust).

This will be recorded as **ADR-013** in `docs/architecture/DECISIONS.md`.

### Configuration Tampering Prevention

```text
Startup validation chain:

1. Load appsettings.json ‚Üí CommandPolicyOptions
2. For each TierOverride:
   a. Is executable in BlockedExecutables? ‚Üí REJECT (InvalidOperationException)
   b. Is tier set to Dangerous? ‚Üí REJECT (InvalidOperationException)
   c. Does executable contain path separators? ‚Üí REJECT
   d. Does executable contain shell metacharacters? ‚Üí REJECT
   e. Do argument patterns contain shell metacharacters? ‚Üí REJECT
   f. Is executable empty/null/whitespace? ‚Üí REJECT
   g. Is argument pattern null (wildcard for all args)? ‚Üí WARN (log warning, allow)
3. All checks pass ‚Üí config is valid, application starts
4. Any check fails ‚Üí application refuses to start with descriptive error
```

### Argument Classification Edge Cases

| Scenario | Input | Classification | Rationale |
|---|---|---|---|
| No arguments | `git` (no args) | Moderate (default for git) | Git without args shows status-like info, but could have side effects in some configs |
| Empty argument list | `git []` | Moderate (default for git) | Same as no arguments |
| Unknown argument | `git worktree` | Moderate (default for git) | Not in any specific pattern ‚Üí executable's default |
| Flag only | `git -v` | Moderate (default for git) | `-v` not in any pattern ‚Üí executable's default |
| Compound dotnet | `dotnet nuget push` | Elevated | `nuget` matches Elevated pattern |
| Compound dotnet unknown | `dotnet custom-tool` | Moderate (default for dotnet) | `custom-tool` not in any pattern ‚Üí dotnet's default |
| Case variation | `GIT STATUS` | Safe | Case-insensitive matching |
| With .exe suffix | `git.exe status` | Safe | `.exe` stripped before matching |
| Read-only tool with args | `cat --number file.txt` | Safe | `cat` is always Safe |
| Script execution | `python script.py` | Moderate | Default for unmatched python args |

---

## Approval UI Changes

### Current (v0.2.0)

```text
‚öô Claude wants to run: git status
  ‚ö†Ô∏è Warning: This will execute a shell command on your system.
  Allow? [Y]es / [N]o
```

### New (v0.3.0)

**Safe (auto-approved):**
```text
[dim]‚öô Auto-approved (Safe): git status[/]
```

**Moderate in trusted directory (auto-approved):**
```text
[dim]‚öô Auto-approved (Moderate ‚Äî trusted dir): dotnet build[/]
```

**Moderate outside trusted directory (prompted):**
```text
‚öô Claude wants to run: dotnet build
  Risk Tier: üü¢ MODERATE (not in trusted directory)
  Working Directory: C:\Users\me\Downloads\untrusted-project
  Justification: Building the project to check for errors

  Allow? [Y]es / [N]o / [A]lways for this session
```

**Elevated (always prompted):**
```text
‚öô Claude wants to run: git push origin main
  Risk Tier: üü° ELEVATED
  Working Directory: C:\Projects\MyApp
  Justification: Pushing committed changes to remote repository

  Allow? [Y]es / [N]o
```

**Dangerous (blocked ‚Äî never shown):**
```text
(Not shown ‚Äî blocked before reaching UI, error returned to Claude)
```

### Key UI Rules

| Tier | In Trusted Dir | UI Behavior |
|---|---|---|
| Safe | N/A | Dim auto-approval message, no prompt |
| Moderate | Yes | Dim auto-approval message, no prompt |
| Moderate | No | Approval prompt with [Y]es/[N]o/[A]lways |
| Elevated | N/A | Approval prompt with [Y]es/[N]o only (no "Always") |
| Dangerous | N/A | Blocked before UI |

---

## System Prompt Changes

The system prompt will include a dynamically generated section listing command tiers so Claude can make informed tool use decisions. This reduces denied command attempts and helps Claude prefer auto-approved commands when possible.

### Generated section (via `ICommandRiskClassifier.GetRules()`):

```text
## Command Execution Risk Tiers

Commands are classified by risk. Your experience will be smoother if you prefer lower-risk commands:

**Safe (auto-approved, no user prompt):**
  git: status, log, diff, show, branch, tag, remote, rev-parse
  dotnet: --version, --info, --list-sdks, --list-runtimes
  Always safe: cat, type, find, dir, where, grep, findstr, tree, echo, sort, head, tail, wc, diff

**Moderate (auto-approved in trusted directories, prompted elsewhere):**
  git: add, commit, stash, checkout, switch, merge
  dotnet: build, test, run, restore, clean, format
  npm/npx: run, test, start, lint, build

**Elevated (always requires user approval):**
  git: push, pull, fetch, clone, rebase, reset, cherry-pick
  dotnet: publish, pack, nuget, new, tool
  npm: install, uninstall, update, publish, link
  pip: install, uninstall, download

**Dangerous (always blocked):**
  powershell, cmd, curl, wget, and others ‚Äî these will always fail.

Unknown commands are blocked. If you need a specific tool, ask the user.
```

---

## Audit Logging Changes

| Tier | Log Level | Auto-Approved | Example |
|---|---|---|---|
| Safe | Debug | Yes | `[DBG] Command classified: git status ‚Üí Safe (auto-approved)` |
| Moderate (trusted dir) | Information | Yes | `[INF] Command classified: dotnet build ‚Üí Moderate (auto-approved, trusted dir: C:\Projects\MyApp)` |
| Moderate (prompted) | Information | No | `[INF] Command classified: dotnet build ‚Üí Moderate (requires approval)` |
| Elevated | Warning | No | `[WRN] Command classified: git push origin main ‚Üí Elevated (requires approval)` |
| Dangerous | Error | N/A | `[ERR] Security violation: powershell ‚Üí Dangerous (blocked)` (existing behavior) |

---

## Implementation Roadmap

### Issue Dependency Graph

```text
#N+1 (Core abstractions)
  ‚îú‚îÄ‚îÄ‚Üí #N+2 (Default risk rules + classifier)
  ‚îÇ      ‚îî‚îÄ‚îÄ‚Üí #N+4 (GraduatedCommandPolicy)
  ‚îÇ             ‚îú‚îÄ‚îÄ‚Üí #N+5 (RunCommandTool refactor)
  ‚îÇ             ‚îÇ      ‚îú‚îÄ‚îÄ‚Üí #N+6 (Approval UI update)
  ‚îÇ             ‚îÇ      ‚îú‚îÄ‚îÄ‚Üí #N+7 (System prompt update)
  ‚îÇ             ‚îÇ      ‚îî‚îÄ‚îÄ‚Üí #N+8 (Audit logging)
  ‚îÇ             ‚îî‚îÄ‚îÄ‚Üí #N+9 (Adversarial tests)
  ‚îî‚îÄ‚îÄ‚Üí #N+3 (Config overrides)
         ‚îî‚îÄ‚îÄ‚Üí #N+4 (GraduatedCommandPolicy)
                ‚îî‚îÄ‚îÄ‚Üí #N+10 (Release docs + verification)
```

### Issue Summary Table

| # | Issue | Type | Depends On | Est. Tests |
|---|---|---|---|---|
| N+1 | Core abstractions (enums, interfaces, records) | Architecture | None | ~15 |
| N+2 | Default risk rules and classifier | Security | N+1 | ~60 |
| N+3 | Configurable tier overrides | Configuration | N+1 | ~20 |
| N+4 | GraduatedCommandPolicy | Security | N+2, N+3 | ~30 |
| N+5 | RunCommandTool refactor + DI | Refactor | N+4 | ~20 |
| N+6 | Approval UI update | UI | N+5 | ~10 |
| N+7 | System prompt update | Enhancement | N+5 | ~5 |
| N+8 | Audit logging for tiers | Observability | N+5 | ~10 |
| N+9 | Adversarial security tests | Testing | N+4 | ~60 |
| N+10 | Release docs + verification | Documentation | All | 0 |
| **Total** | | | | **~230** |

---

## Testing Strategy

### Test Categories

1. **Unit Tests** ‚Äî Every new class has a corresponding test class
2. **Classification Tests** ‚Äî Every default tier rule has a dedicated test
3. **Policy Evaluation Tests** ‚Äî Each tier path tested with mocked dependencies
4. **Configuration Validation Tests** ‚Äî Every safety invariant has a dedicated test
5. **Adversarial Tests** ‚Äî Attack vector simulations following existing pattern
6. **Integration Tests** ‚Äî `RunCommandTool` with real classifier and policy
7. **Regression Tests** ‚Äî All existing 903+ tests must continue to pass

### Running Tests

```bash
# All tests
dotnet test

# v0.3.0 specific tests
dotnet test --filter "FullyQualifiedName~CommandRisk|FullyQualifiedName~GraduatedCommand|FullyQualifiedName~CommandTierConfig"

# Adversarial tests only
dotnet test --filter "FullyQualifiedName~Adversarial"

# Security tests (all versions)
dotnet test --filter "Category=Security"
```

---

## Rollback Plan

If v0.3.0 introduces regressions:

1. **Revert to v0.2.0 behavior:** Set all tiers to Elevated in config ‚Üí everything requires approval (same as v0.2.0)
2. **Disable classifier:** Remove `ICommandPolicy` registration from DI ‚Üí falls back to `ISecurityPolicy.IsApprovalRequired()` which returns `true` for `run_command`
3. **Git revert:** All changes are in new files (additive). Reverting commits removes the feature cleanly.

---

## Risks and Mitigations

| Risk | Severity | Probability | Mitigation |
|---|---|---|---|
| Misclassification of destructive command as Safe | High | Low | Exhaustive tests, fail-closed for unknowns, metacharacter pre-check |
| Configuration allows unsafe promotion | High | Low | Startup validation blocks Dangerous promotions |
| Increased code complexity | Medium | Medium | Clean interface separation, well-tested components |
| Breaking change to orchestrator | Medium | Low | `CommandApprovalRequiredException` follows existing `DirectoryAccessRequiredException` pattern |
| Approval fatigue reduction leads to less attention on Elevated prompts | Low | Medium | Elevated prompts shown with üü° warning, audit logging captures all decisions |

---

## Success Criteria

- [ ] `git status` executes without ANY user prompt (Safe, auto-approved)
- [ ] `dotnet build` in a trusted directory executes without user prompt (Moderate, trusted)
- [ ] `dotnet build` in an untrusted directory prompts the user (Moderate, untrusted)
- [ ] `git push` ALWAYS prompts the user (Elevated)
- [ ] `powershell` is ALWAYS blocked (Dangerous, unchanged)
- [ ] Unknown commands are ALWAYS blocked (fail-closed)
- [ ] Configuration cannot promote `powershell` to any other tier
- [ ] All existing 903+ tests pass (zero regressions)
- [ ] ~230 new tests pass
- [ ] Approval UI shows tier labels
- [ ] System prompt includes tier information
- [ ] Every command logged with tier and approval status

---

## Related Documents

- `docs/versions/v0.2.0.md` ‚Äî Predecessor version (dynamic directory scoping)
- `docs/architecture/OVERVIEW.md` ‚Äî Component architecture
- `docs/architecture/SECURITY.md` ‚Äî Security threat model
- `docs/architecture/DECISIONS.md` ‚Äî Architecture Decision Records
- `docs/status/PROGRESS.md` ‚Äî Progress tracker
- `docs/guides/TESTING.md` ‚Äî Test strategy
- `docs/guides/APPROVAL-HANDLER.md` ‚Äî Approval handler documentation
- `src/Krutaka.Tools/CommandPolicy.cs` ‚Äî Current allowlist/blocklist implementation
- `src/Krutaka.Core/ISecurityPolicy.cs` ‚Äî Current security policy interface
- `src/Krutaka.Tools/RunCommandTool.cs` ‚Äî Current command execution tool
- `src/Krutaka.Tools/ServiceExtensions.cs` ‚Äî Current DI registration
